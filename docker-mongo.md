# Mongo

### Введение

MongoDB – это нереляционная база данных с открытым исходным кодом, поддерживающая документоориентированные системы хранения объектов в формате, подобном JSON. Она использует гибкую модель данных, позволяющую хранить данные любой структуры, и имеет широкий набор возможностей, включая полную поддержку индексов, сегментирование и репликацию.

Благодаря отсутствию структурированной схемы, Mongo может расти и изменяться вместе с моделью данных. Если вы работаете в недавно образованной компании, которая лелеет грандиозные планы или уже накопила столько данных, что возникла потребность в горизонтальном масштабировании, то присмотритесь к MongoDB.

| **SQL** | **MongoDB** |
| :--- | :--- |
| Таблица | Коллекция |
| Ряд | Документ |
| Столбец | Поле |
| Первичный ключ | ObjectId |
| Индекс | Индекс |
| Представление | Представление |
| Вложенная таблица или объект | Встроенный документ |

### Установка

Официальный образ [https://hub.docker.com/\_/mongo/](https://hub.docker.com/_/mongo/)

```bash
vitalij$ docker run --name mongo \ 
        -v /Volumes/Data/Docker/mongo/data/db:/data/db \
        -v /Volumes/Data/Docker/mongo/data/conf:/data/configdb \
        -e MONGO_INITDB_ROOT_USERNAME=admin \
        -e MONGO_INITDB_ROOT_PASSWORD=admin \
        -p 27017:27017 \
        -d mongo
```

Клиент Robo 3T [https://robomongo.org/download](https://robomongo.org/download)

![](/assets/10042134.png)

### Основы

MongoDB хранит BSON в коллекциях, а коллекции в БД.

BSON:

![](/assets/bson.png)

Коллекция:

![](/assets/collections.png)

Типы даных:

* **Integer **для хранения целочисленных значений. В зависимости от сервера может быть как 32-битным, так и 64-битным.

* **Double **для хранения значений с плавающей точкой

* **Boolean **для хранения логических \(true / false\) значений.

* **String **для хранения символьных строк. В MongoDB используется кодировка UTF-8.

* **Arrays **для хранения массивов значений по одному ключу.

* **Object **для встроенных документов.

* **Symbol **также, как и**String**, но, обычно, резервируется для языков, которые используют специальные символы.

* **Null **для хранения значения Null.

* **Timestamp **для хранения даты и времени

* **Min / Max **для сравнения значений с наибольшим и наименьшим BSON \(Binary JSON\) элементом.

* **Object ID **для хранения ID документа.

* **Regular Expression **для хранения регулярных выражений.

* **Code **для хранения JavaScript кода в документе.

* **Binary data **позволяет хранить бинарные данные.

* **Date **для хранения текущей даты или времени в UNIX формате.

Создание БД:

```
use book
//switched to db book

db.getName()
//book
```

Для создания коллекции достаточно просто добавить в нее первую запись\(или db.createCollection\('it'\)\). Поскольку в Mongo нет схем, то заранее ничего определять не надо. Более того, даже сама база данных book физически не существует, пока мы не добавим в нее первый документ.

Фигурные скобки {...} обозначают объект \(аналог ассоциативного массива или хеш-таблицы\), содержащий ключи и значения, а квадрат- ные скобки \[...\] – линейный массив. Значения могут быть вложенными, причем глубина вложенности не ограничена.

#### Создание документов

```
db.it.insert({title: 'Spring', lang: 'Java'});
db.it.insert({title: 'Hibernate' , count: 234})

var java = {title: 'Java 8'};
db.it.insert(java)

db.it.insertMany([{title: '1'}, {title: '2'}])

```

![](/assets/m01.png)

Объект ObjectId всегда занимает 12 байтов и состоит из временной метки, идентификатора клиентской машины, идентификатора клиентского процесса и 3-байтового инкрементируемого счетчика.

```
show collections
//it
```

#### Поиск документов:

```
db.getCollection('it').find({}) //все
db.getCollection('it').find({lang: 'Java'}) //фильтр по lang
db.getCollection('it').find({}, {title:1, _id: 0}) // выводить только title

db.getCollection('it').find({title: /^H/, count: { $lt : 1000 }}) //начинается на 'H', count < 1000

db.getCollection('it').find({
   $or : [
    { title: /^H/},
    { lang: 'Java'}
]}) // или и др

//$ne Не равно
// $lt Меньше
// $lte Меньше или равно
// $gt Больше
// $gte Больше или равно
// $exists Проверяет существование поля
// $all Соответствие всем элементам массива
// $in Соответствие хотя бы одному элементу массива 
// $nin Несоответствие ни одному элементу массива 
// $elemMatch Соответствие всех полей вложенного документа 
// $or Или
// $nor Не или
// $size Соответствие размеру массива
// $mod Деление по модулю
// $type Соответствие, если поле имеет указанный тип 
// $not Отрицание
 
```

#### ![](/assets/3423.png)

#### Обновление:

Функция update\(criteria,operation\) принимает два обязательных параметра. Первый – критерий отбора – такой же, как для функции find\(\). Второй – либо объект, поля которого заменяют поля отобранных документов, либо модификатор.

```
db.it.update(
 { _id : ObjectId('5bba3f3fb7ad7086c4cb44a5') },
 { $set : { 'count' : 12 } }
);
```

![](/assets/5345.png)

```

db.it.update(
 { _id : ObjectId('5bba3f3fb7ad7086c4cb44a5') },
 { $inc : { 'count' : 10 } }
); //увеличение на 10

// $set Записывает указанное значение в указанное поле 
// $unset Удаляет поле
// $inc Прибавляет указанное число к указанному полю 
// $pop Удаляет последний (или первый) элемент из массива 
// $push Помещает новый элемент в массив
// $pushAll Помещает все указанные элементы в массив 
// $addToSet Аналогичен push, но дубликаты не добавляются
// $pull Удаляет из массива подходящее значение, если оно в нем есть
// $pullAll Удаляет из массива все подходящие значения
```

#### Удаление

```
var java = {title: 'Java 8'};

db.it.find(java)
db.it.remove(java)
```

## Индексирование

При создании любой коллекции Mongo автоматически строит индекс по полю\_id. Эти индексы присутствуют в коллекцииsystem. indexes. Следующий запрос покажет все имеющиеся в базе данных индексы:

```
db.system.indexes.find()

```

Для построения индекса вызывается метод коллекции ensure-Index\(fields,options\). Параметр fields– это объект, содержащий поля, по которым строится индекс, а параметр options описывает тип индекса. В данном случае нам нужен уникальный индекс по полю title, причем обнаруженные при построении дубликаты должны просто удаляться.

```
db.it.ensureIndex(
 { title : 1 },
 { unique : true, dropDups : true }
)
```

```
db.getCollection('it').find({title: 'Java 8'}).explain({})

```

![](/assets/4243.png)

explain\(\)– полезная функция, но использовать ее следует только при проверке конкретных запросов. Для изучения производительности системы в тестовом или промышленном режиме понадобитсясистемный профилировщик.

Зададим уровень профилирования 2 \(при уровне 2 сохраняется информация обо всех запросах, при уровне 1 – только о «медленных» запросах, исполнявшихся более 100 миллисекунд\) и запустим find\(\), как обычно.



